/*
 * GStreamer
 * Copyright (C) 2005 Thomas Vander Stichele <thomas@apestaart.org>
 * Copyright (C) 2005 Ronald S. Bultje <rbultje@ronald.bitfreak.net>
 * Copyright (C) 2008 Michael Sheldon <mike@mikeasoft.com>
 * Copyright (C) 2010 Lucas Pantuza Amorim <lucas@vettalabs.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * Alternatively, the contents of this file may be used under the
 * GNU Lesser General Public License Version 2.1 (the "LGPL"), in
 * which case the following provisions apply instead of the ones
 * mentioned above:
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/**
 * SECTION:element-haaradjust
 *
 * Performs haaradjust using haardetect. It depends
 * on 'haardetect' events generated by the 'haardetect' plugin.
 *
 * <refsect2>
 * <title>Example launch line</title>
 * |[
 * gst-launch-0.10 videotestsrc ! decodebin ! ffmpegcolorspace !
 *      bgfgcodebook mask=TRUE model-min=40 model-max=50 n-morphology-itr=3 !
 *      facedetect profile=/apps/opencv/opencv/data/haarcascades/haarcascade_upperbody.xml min-neighbors=5 !
 *      haaradjust object-type=UPPERBODY verbose=TRUE display=TRUE !
 *      ffmpegcolorspace ! xvimagesink sync=false
 * ]|
 * </refsect2>
 */

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#include "gsthaaradjust.h"

#include <gst/gst.h>
#include <gst/gststructure.h>
#include <cvaux.h>
#include <highgui.h>

GST_DEBUG_CATEGORY_STATIC (gst_haar_adjust_debug);
#define GST_CAT_DEFAULT gst_haar_adjust_debug

#define OBJECT_TYPE_UPPER_BODY        "upperbody"
#define OBJECT_TYPE_LOWER_BODY        "lowerbody"
#define DEFAULT_OBJECT_TYPE           OBJECT_TYPE_UPPER_BODY

#define DEFAULT_HEIGHT_ADJUSTMENT     3.0f

enum
{
    PROP_0,
    PROP_VERBOSE,
    PROP_DISPLAY,
    PROP_OBJECT_TYPE,
    PROP_HEIGHT_ADJUSTMENT
};

// the capabilities of the inputs and outputs.
static GstStaticPadTemplate sink_factory = GST_STATIC_PAD_TEMPLATE("sink",
    GST_PAD_SINK,
    GST_PAD_ALWAYS,
    GST_STATIC_CAPS("video/x-raw-rgb")
    );

static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE("src",
    GST_PAD_SRC,
    GST_PAD_ALWAYS,
    GST_STATIC_CAPS("video/x-raw-rgb")
    );

GST_BOILERPLATE(GstHaarAdjust, gst_haar_adjust, GstElement, GST_TYPE_ELEMENT);

static void          gst_haar_adjust_set_property (GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec);
static void          gst_haar_adjust_get_property (GObject *object, guint prop_id, GValue *value, GParamSpec *pspec);
static gboolean      gst_haar_adjust_set_caps     (GstPad *pad, GstCaps *caps);
static GstFlowReturn gst_haar_adjust_chain        (GstPad *pad, GstBuffer *buf);
static gboolean      events_cb                    (GstPad *pad, GstEvent *event, gpointer user_data);

// clean up
static void
gst_haar_adjust_finalize(GObject *obj)
{
    GstHaarAdjust *filter = GST_HAARADJUST(obj);

    if (filter->image)       cvReleaseImage(&filter->image);
    if (filter->object_type) g_free(filter->object_type);

    G_OBJECT_CLASS(parent_class)->finalize(obj);
}

// gobject vmethod implementations
static void
gst_haar_adjust_base_init(gpointer gclass)
{
    GstElementClass *element_class = GST_ELEMENT_CLASS(gclass);

    gst_element_class_set_details_simple(element_class,
                                         "haaradjust",
                                         "Filter/Video",
                                         "Adjusts the ROIs received by an upstream 'haar detection' element",
                                         "Lucas Pantuza Amorim <lucas@vettalabs.com>");

    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&src_factory));
    gst_element_class_add_pad_template(element_class, gst_static_pad_template_get(&sink_factory));
}

// initialize the haaradjust's class
static void
gst_haar_adjust_class_init(GstHaarAdjustClass *klass)
{
    GObjectClass *gobject_class;

    gobject_class = (GObjectClass*) klass;
    parent_class  = g_type_class_peek_parent(klass);

    gobject_class->finalize     = GST_DEBUG_FUNCPTR(gst_haar_adjust_finalize);
    gobject_class->set_property = gst_haar_adjust_set_property;
    gobject_class->get_property = gst_haar_adjust_get_property;

    g_object_class_install_property(gobject_class, PROP_VERBOSE,
                                    g_param_spec_boolean("verbose", "Verbose", "Print useful debugging information to stdout",
                                                         FALSE, G_PARAM_READWRITE));

    g_object_class_install_property(gobject_class, PROP_DISPLAY,
                                    g_param_spec_boolean("display", "Display", "Highlight the adjusted ROI on the output video stream",
                                                         FALSE, G_PARAM_READWRITE));

    g_object_class_install_property(gobject_class, PROP_OBJECT_TYPE,
                                    g_param_spec_string("object-type", "Type of identified HAAR object", "The type of the identified haar object: 'upperbody' or 'lowerbody'",
                                                        DEFAULT_OBJECT_TYPE, G_PARAM_READWRITE));

    g_object_class_install_property(gobject_class, PROP_HEIGHT_ADJUSTMENT,
                                    g_param_spec_float("height-adjustment", "Height adjustment", "Adjustment multiplier that will be used to set the height of the ROI (based on the src HAAR ROI's height)",
                                                       0.0f, 9999.0f, DEFAULT_HEIGHT_ADJUSTMENT, G_PARAM_READWRITE));
}

// initialize the new element
// instantiate pads and add them to element
// set pad calback functions
// initialize instance structure
static void
gst_haar_adjust_init(GstHaarAdjust *filter, GstHaarAdjustClass *gclass)
{
    filter->sinkpad = gst_pad_new_from_static_template(&sink_factory, "sink");
    gst_pad_set_setcaps_function(filter->sinkpad, GST_DEBUG_FUNCPTR(gst_haar_adjust_set_caps));
    gst_pad_set_getcaps_function(filter->sinkpad, GST_DEBUG_FUNCPTR(gst_pad_proxy_getcaps));
    gst_pad_set_chain_function(filter->sinkpad, GST_DEBUG_FUNCPTR(gst_haar_adjust_chain));

    filter->srcpad = gst_pad_new_from_static_template(&src_factory, "src");
    gst_pad_set_getcaps_function(filter->srcpad, GST_DEBUG_FUNCPTR(gst_pad_proxy_getcaps));

    gst_element_add_pad(GST_ELEMENT(filter), filter->sinkpad);
    gst_element_add_pad(GST_ELEMENT(filter), filter->srcpad);

    filter->verbose           = FALSE;
    filter->display           = FALSE;
    filter->object_type       = g_strdup(DEFAULT_OBJECT_TYPE);
    filter->height_adjustment = DEFAULT_HEIGHT_ADJUSTMENT;
    filter->rect_timestamp    = 0;
    filter->rect_array        = g_array_sized_new(FALSE, FALSE, sizeof(CvRect), 1);
}

static void
gst_haar_adjust_set_property(GObject *object, guint prop_id, const GValue *value, GParamSpec *pspec)
{
    GstHaarAdjust *filter = GST_HAARADJUST(object);

    switch (prop_id) {
        case PROP_VERBOSE:
            filter->verbose = g_value_get_boolean(value);
            break;
        case PROP_DISPLAY:
            filter->display = g_value_get_boolean(value);
            break;
        case PROP_OBJECT_TYPE:
            filter->object_type = g_value_dup_string(value);
            break;
        case PROP_HEIGHT_ADJUSTMENT:
            filter->height_adjustment = g_value_get_float(value);
            break;
        default:
            G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
            break;
    }
}

static void
gst_haar_adjust_get_property(GObject *object, guint prop_id, GValue *value, GParamSpec *pspec)
{
    GstHaarAdjust *filter = GST_HAARADJUST(object);

    switch (prop_id) {
        case PROP_VERBOSE:
            g_value_set_boolean(value, filter->verbose);
            break;
        case PROP_DISPLAY:
            g_value_set_boolean(value, filter->display);
            break;
        case PROP_OBJECT_TYPE:
            g_value_take_string(value, filter->object_type);
            break;
        case PROP_HEIGHT_ADJUSTMENT:
            g_value_set_float(value, filter->height_adjustment);
            break;
        default:
            G_OBJECT_WARN_INVALID_PROPERTY_ID(object, prop_id, pspec);
            break;
    }
}

// GstElement vmethod implementations

// this function handles the link with other elements
static gboolean
gst_haar_adjust_set_caps(GstPad *pad, GstCaps *caps)
{
    GstHaarAdjust *filter;
    GstPad        *other_pad;
    GstStructure  *structure;
    gint           width, height, depth;

    filter = GST_HAARADJUST(gst_pad_get_parent(pad));
    structure = gst_caps_get_structure(caps, 0);
    gst_structure_get_int(structure, "width",  &width);
    gst_structure_get_int(structure, "height", &height);
    gst_structure_get_int(structure, "depth",  &depth);

    filter->image   = cvCreateImage(cvSize(width, height), depth/3, 3);

    // add roi event probe on the sinkpad
    gst_pad_add_event_probe(filter->sinkpad, (GCallback) events_cb, filter);

    other_pad = (pad == filter->srcpad) ? filter->sinkpad : filter->srcpad;
    gst_object_unref(filter);
    return gst_pad_set_caps(other_pad, caps);
}

// chain function; this function does the actual processing
static GstFlowReturn
gst_haar_adjust_chain(GstPad *pad, GstBuffer *buf)
{
    GstHaarAdjust *filter;

    // sanity checks
    g_return_val_if_fail(pad != NULL, GST_FLOW_ERROR);
    g_return_val_if_fail(buf != NULL, GST_FLOW_ERROR);

    filter = GST_HAARADJUST(GST_OBJECT_PARENT(pad));

    filter->image->imageData = (char*) GST_BUFFER_DATA(buf);

    if ((filter->rect_timestamp == GST_BUFFER_TIMESTAMP(buf)) &&
        (filter->rect_array != NULL) &&
        (filter->rect_array->len > 0)) {
        guint i;

        for (i = 0; i < filter->rect_array->len; ++i) {
            CvRect        rect;
            GstEvent     *event;
            GstMessage   *message;
            GstStructure *structure;

            rect = g_array_index(filter->rect_array, CvRect, i);

            // adjust ROIs
            if (g_strcasecmp(filter->object_type, OBJECT_TYPE_UPPER_BODY) == 0) {
                rect.height *= filter->height_adjustment;
            } else if (g_strcasecmp(filter->object_type, OBJECT_TYPE_LOWER_BODY) == 0) {
                rect.y -= rect.height;
                rect.height *= filter->height_adjustment;
            } else {
                GST_ERROR("invalid object type: '%s'", filter->object_type);
                break;
            }

            // if greater than the image margins, set new limits
            if (rect.x < 0) rect.x = 0;
            if (rect.y < 0) rect.y = 0;
            if (rect.x + rect.width  > filter->image->width ) rect.width  = filter->image->width  - rect.x;
            if (rect.y + rect.height > filter->image->height) rect.height = filter->image->height - rect.y;

            if (filter->verbose)
                GST_INFO("[rect] x: %d, y: %d, width: %d, height: %d",
                         rect.x, rect.y, rect.width, rect.height);

            if (filter->display) {
                cvRectangle(filter->image,
                            cvPoint(rect.x, rect.y),
                            cvPoint(rect.x + rect.width, rect.y + rect.height),
                            CV_RGB(255, 0, 255), 1, 8, 0);
            }

            // send downstream event and bus message with the rect info
            structure = gst_structure_new("haar-adjust-roi",
                                          "x",         G_TYPE_UINT,   rect.x,
                                          "y",         G_TYPE_UINT,   rect.y,
                                          "width",     G_TYPE_UINT,   rect.width,
                                          "height",    G_TYPE_UINT,   rect.height,
                                          "timestamp", G_TYPE_UINT64, GST_BUFFER_TIMESTAMP(buf),
                                          NULL);

            message = gst_message_new_element(GST_OBJECT(filter), gst_structure_copy(structure));
            gst_element_post_message(GST_ELEMENT(filter), message);

            event   = gst_event_new_custom(GST_EVENT_CUSTOM_DOWNSTREAM, structure);
            gst_pad_push_event(filter->srcpad, event);
        }
    }

    gst_buffer_set_data(buf, (guint8*) filter->image->imageData, (guint) filter->image->imageSize);
    return gst_pad_push(filter->srcpad, buf);
}

// callbacks
static
gboolean events_cb(GstPad *pad, GstEvent *event, gpointer user_data)
{
    GstHaarAdjust  *filter;
    const GstStructure *structure;

    filter = GST_HAARADJUST(user_data);

    // sanity checks
    g_return_val_if_fail(pad    != NULL, FALSE);
    g_return_val_if_fail(event  != NULL, FALSE);
    g_return_val_if_fail(filter != NULL, FALSE);

    structure = gst_event_get_structure(event);

    //TODO rename structure "face"
    if ((structure != NULL) && (strcmp(gst_structure_get_name(structure), "haar-detect-roi") == 0)) {
        CvRect rect;
        GstClockTime timestamp;

        gst_structure_get((GstStructure*) structure,
                          "x",         G_TYPE_UINT,   &rect.x,
                          "y",         G_TYPE_UINT,   &rect.y,
                          "width",     G_TYPE_UINT,   &rect.width,
                          "height",    G_TYPE_UINT,   &rect.height,
                          "timestamp", G_TYPE_UINT64, &timestamp, NULL);

        if (timestamp > filter->rect_timestamp) {
            filter->rect_timestamp = timestamp;
            g_array_free(filter->rect_array, TRUE);
            filter->rect_array = g_array_sized_new(FALSE, FALSE, sizeof(CvRect), 1);
        }
        g_array_append_val(filter->rect_array, rect);
    }

    return TRUE;
}

// entry point to initialize the plug-in; initialize the plug-in itself
// and registers the element factories and other features
gboolean
gst_haar_adjust_plugin_init (GstPlugin * plugin)
{
    // debug category for filtering log messages
    GST_DEBUG_CATEGORY_INIT(gst_haar_adjust_debug, "haaradjust", 0,
                            "Adjusts the ROIs received by an upstream 'haar detection' element");

    return gst_element_register(plugin, "haaradjust", GST_RANK_NONE, GST_TYPE_HAARADJUST);
}
